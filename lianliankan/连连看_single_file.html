<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è¿è¿çœ‹ â€” å•æ–‡ä»¶ï¼ˆä¿®å¤ onTileClickï¼‰</title>
  <style>
    :root{ --bg:#0f1724; --card:#e6eef8; --accent:#06b6d4; --glass: rgba(255,255,255,0.06); }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071024 0%, #081527 60%);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:18px}
    .app{max-width:980px;width:100%;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));border-radius:14px;padding:14px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-size:18px;font-weight:700}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--card);cursor:pointer;font-weight:600}
    .btn.small{padding:6px 8px;font-size:13px}
    .board-wrap{display:flex;gap:12px}
    .sidebar{min-width:180px;padding:8px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));}
    .board{flex:1;display:flex;align-items:center;justify-content:center;padding:8px}

    .grid{width:100%;height:calc(min(78vh,720px));display:grid;gap:6px;touch-action:none;position:relative}
    .cell{background:transparent;border-radius:10px;display:flex;align-items:center;justify-content:center;user-select:none;overflow:hidden;position:relative}
    .tile{width:100%;height:100%;display:flex;align-items:center;justify-content:center;border-radius:10px;font-size:20px;transform-origin:center;transition:transform .15s ease,opacity .18s ease;box-shadow:0 6px 16px rgba(2,6,23,0.6)}
    .tile.cover{background:linear-gradient(180deg,#ffffff22,#00000022);backdrop-filter: blur(6px);}
    .tile.hidden{opacity:0;transform:scale(.8);pointer-events:none}
    .tile.selected{outline:3px solid rgba(6,182,212,0.9);transform:scale(1.04)}
    .path-line{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}

    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px;font-size:13px}
    .range{width:120px}

    @media (max-width:720px){.app{padding:10px;border-radius:10px}.board-wrap{flex-direction:column}.sidebar{width:100%;display:flex;flex-direction:row;justify-content:space-between}.grid{height:64vh}}
  </style>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4402948071877561"
    crossorigin="anonymous"></script>
  <meta name="google-adsense-account" content="ca-pub-4402948071877561">
</head>
<body>
  <div class="app" role="application">
    <div class="header">
      <div class="title">è¿è¿çœ‹ â€” å•æ–‡ä»¶ç‰ˆï¼ˆä¿®å¤ï¼‰</div>
      <div class="controls">
        <select id="difficulty" class="btn small" title="éš¾åº¦">
          <option value="8x6">ç®€å•ï¼ˆ8Ã—6ï¼‰</option>
          <option value="10x8" selected>ä¸­ç­‰ï¼ˆ10Ã—8ï¼‰</option>
          <option value="12x10">å›°éš¾ï¼ˆ12Ã—10ï¼‰</option>
        </select>
        <button id="newBtn" class="btn small">æ–°æ¸¸æˆ</button>
        <button id="hintBtn" class="btn small">æç¤º</button>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board">
        <div id="grid" class="grid" aria-label="è¿è¿çœ‹æ£‹ç›˜"></div>
      </div>

      <div class="sidebar">
        <div style="padding:8px">
          <div class="status"><div>æ­¥æ•°ï¼š<span id="moves">0</span></div><div>åŒ¹é…ï¼š<span id="matched">0</span></div></div>
          <div style="height:10px"></div>
          <div>è®¡æ—¶ï¼š<strong id="timer">00:00</strong></div>
          <div style="height:10px"></div>
          <div>å‰©ä½™å¯¹æ•°ï¼š<strong id="remaining">0</strong></div>
        </div>
        <div style="padding:8px;display:flex;flex-direction:column;gap:8px">
          <label style="font-size:13px">ç¼©æ”¾æ£‹ç›˜<input id="scale" type="range" min="60" max="120" value="100" class="range"/></label>
          <div style="font-size:12px;color:#bcd">ç‚¹å‡»æˆ–è§¦æ‘¸é€‰æ‹©ä¸¤å¼ ç›¸åŒçš„ç‰Œï¼Œé€šè¿‡ä¸è¶…è¿‡ä¸¤æ¬¡æ‹å¼¯çš„è¿çº¿å³å¯æ¶ˆé™¤å®ƒä»¬ã€‚</div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div>æç¤ºä¼šæ¶ˆè€—ä¸€æ­¥ã€‚å¯åœ¨ç§»åŠ¨ç«¯è§¦æ‘¸é€‰æ‹©ã€‚</div>
      <div style="opacity:.8">Made with â¤ï¸ â€” å•æ–‡ä»¶</div>
    </div>
  </div>

  <script>
  (function(){
    // --- çŠ¶æ€ä¸å…ƒç´  ---
    const EMOJIS = ['ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ¨','ğŸ¯','ğŸ¦','ğŸ®','ğŸ·','ğŸ¸','ğŸµ','ğŸ”','ğŸ§','ğŸ¢','ğŸ','ğŸ¦„'];
    const gridEl = document.getElementById('grid');
    const movesEl = document.getElementById('moves');
    const matchedEl = document.getElementById('matched');
    const remainingEl = document.getElementById('remaining');
    const timerEl = document.getElementById('timer');
    const difficultyEl = document.getElementById('difficulty');
    const newBtn = document.getElementById('newBtn');
    const hintBtn = document.getElementById('hintBtn');
    const scaleEl = document.getElementById('scale');

    let rows = 10, cols = 8;
    let board = [];
    let tilesMap = {}; // id -> {r,c,val,el}
    let selected = null;
    let moves = 0, matchedCount = 0, totalPairs = 0;
    let timer = 0, timerId = null;

    // --- æ—¶é’Ÿè¾…åŠ© ---
    function resetTimer(){ clearInterval(timerId); timerId = null; timer = 0; timerEl.textContent = '00:00'; }
    function startTimer(){ if(timerId) return; timerId = setInterval(()=>{ timer++; timerEl.textContent = formatTime(timer); },1000); }
    function formatTime(s){ const m=Math.floor(s/60); const sec=s%60; return String(m).padStart(2,'0')+':'+String(sec).padStart(2,'0'); }

    function setDifficulty(val){ const [c,r] = val.split('x').map(n=>parseInt(n,10)); cols = c; rows = r; }

    // --- ç”Ÿæˆä¸€ä¸ªä¸¥æ ¼å…¨å±€å¯è§£çš„æ£‹ç›˜ ---
    function generateSolvableBoard(){
      const R = rows+2, C = cols+2;
      while(true){
        board = Array.from({length:R}, ()=>Array(C).fill(0));
        tilesMap = {};
        const innerCount = rows*cols;
        totalPairs = Math.floor(innerCount/2);
        const symbols = [];
        let pickIndex = 0;
        for(let i=0;i<totalPairs;i++){
          if(pickIndex>=EMOJIS.length) pickIndex = 0;
          symbols.push(EMOJIS[pickIndex]); pickIndex++;
        }
        const tileVals = [...symbols, ...symbols];
        shuffle(tileVals);
        let idCounter = 1;
        for(let r=1;r<=rows;r++){
          for(let c=1;c<=cols;c++){
            const val = tileVals[(r-1)*cols + (c-1)] || '';
            if(val === ''){ board[r][c] = 0; continue; }
            board[r][c] = idCounter;
            tilesMap[idCounter] = { r, c, val };
            idCounter++;
          }
        }
        // éªŒè¯å…¨å±€å¯è§£æ€§
        if(isGloballySolvable()) return;
        // å¦åˆ™å¾ªç¯é‡è¯•ï¼ˆæ³¨æ„ï¼šæ­¤å¤„å¯èƒ½ä¼šå¤šæ¬¡å°è¯•ï¼Œç”Ÿæˆå¤§ç›˜é¢æ—¶è¾ƒæ…¢ï¼‰
      }
    }

    function isGloballySolvable(){
      const backupBoard = board.map(row => row.slice());
      const backupTiles = JSON.parse(JSON.stringify(tilesMap));
      let pairsLeft = Object.keys(backupTiles).length / 2;

      while(pairsLeft > 0){
        let found = false;
        const ids = Object.keys(backupTiles).map(Number);
        for(let i=0;i<ids.length;i++){
          for(let j=i+1;j<ids.length;j++){
            const a = backupTiles[ids[i]], b = backupTiles[ids[j]];
            if(!a || !b || a.val !== b.val) continue;
            if(canConnectSim(backupBoard, a.r, a.c, b.r, b.c)){
              // æ¶ˆæ‰è¿™å¯¹å¹¶ç»§ç»­
              backupBoard[a.r][a.c] = 0;
              backupBoard[b.r][b.c] = 0;
              delete backupTiles[ids[i]]; delete backupTiles[ids[j]];
              pairsLeft--; found = true; break;
            }
          }
          if(found) break;
        }
        if(!found) return false;
      }
      return true;
    }

    // ç”¨äºå¯è§£æ€§æ£€æµ‹çš„ç®€åŒ–è¿é€šæ€§æ£€æŸ¥ï¼ˆè¿”å› true/falseï¼‰
    function canConnectSim(boardSim, r1, c1, r2, c2){
      const R = rows+2, C = cols+2;
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      const visited = Array.from({length:R}, ()=>Array.from({length:C}, ()=>Array(4).fill(99)));
      const q = [];
      for(let d=0; d<4; d++){ visited[r1][c1][d] = 0; q.push({r:r1,c:c1,dir:d,turns:0}); }
      function pass(nr,nc){ if(nr<0||nr>=R||nc<0||nc>=C) return false; if(nr===r2&&nc===c2) return true; return boardSim[nr][nc]===0; }
      while(q.length){
        const cur = q.shift();
        let nr = cur.r + dirs[cur.dir][0], nc = cur.c + dirs[cur.dir][1];
        while(nr>=0 && nr<R && nc>=0 && nc<C){
          if(!pass(nr,nc)) break;
          if(nr===r2 && nc===c2) return true;
          for(let nd=0; nd<4; nd++){
            const nt = cur.turns + (nd===cur.dir ? 0 : 1);
            if(nt>2) continue;
            if(visited[nr][nc][nd] > nt){ visited[nr][nc][nd] = nt; q.push({r:nr,c:nc,dir:nd,turns:nt}); }
          }
          nr += dirs[cur.dir][0]; nc += dirs[cur.dir][1];
        }
      }
      return false;
    }

    // --- æ¸²æŸ“æ£‹ç›˜ ---
    function render(){
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      for(let r=1; r<=rows; r++){
        for(let c=1; c<=cols; c++){
          const cell = document.createElement('div'); cell.className = 'cell';
          const id = board[r][c];
          if(id){
            const tile = document.createElement('div'); tile.className = 'tile cover';
            tile.textContent = tilesMap[id].val; tile.dataset.id = id;
            // ç‚¹å‡»ä¸è§¦æ‘¸äº‹ä»¶éƒ½æŒ‡å‘ç»Ÿä¸€å¤„ç†å‡½æ•° onTileClick
            tile.addEventListener('click', onTileClick);
            tile.addEventListener('touchstart', function(e){ e.preventDefault(); onTileClick.call(this, e); }, {passive:false});
            cell.appendChild(tile);
            tilesMap[id].el = tile;
          }
          gridEl.appendChild(cell);
        }
      }
      matchedEl.textContent = matchedCount;
      movesEl.textContent = moves;
      remainingEl.textContent = totalPairs - matchedCount;
      applyScale();
    }

    function applyScale(){ const s = Number(scaleEl.value)/100; gridEl.style.transform = `scale(${s})`; gridEl.style.transformOrigin = 'center'; }

    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]] = [arr[j],arr[i]]; } }

    // --- å…³é”®ï¼šå¤„ç†ç‚¹å‡»ï¼ˆå·²ä¿®å¤ï¼‰ ---
    function onTileClick(e){
      // æ”¯æŒé€šè¿‡ addEventListener çš„è°ƒç”¨æˆ– call(this, e) çš„è°ƒç”¨
      const tileEl = (e && e.currentTarget) || (this && this.dataset && this.dataset.id ? this : (e && e.target)) ;
      if(!tileEl) return;
      const id = Number(tileEl.dataset.id);
      if(!id || !tilesMap[id]) return;

      if(!timerId) startTimer();
      if(tileEl.classList.contains('hidden')) return;

      // å–æ¶ˆé€‰æ‹©
      if(selected && selected === id){ tileEl.classList.remove('selected'); selected = null; return; }

      if(selected === null){ selected = id; tileEl.classList.add('selected'); return; }

      // ç¬¬äºŒæ¬¡é€‰æ‹©ï¼šå°è¯•åŒ¹é…
      const firstId = selected; const secondId = id;
      moves++; movesEl.textContent = moves;
      const firstEl = tilesMap[firstId] && tilesMap[firstId].el;
      if(firstEl) firstEl.classList.remove('selected');
      selected = null;
      if(firstId === secondId) return;

      // å€¼ä¸åŒç›´æ¥åé¦ˆ
      if(tilesMap[firstId].val !== tilesMap[secondId].val){
        if(tilesMap[secondId] && tilesMap[secondId].el){
          tilesMap[secondId].el.animate([{transform:'translateX(-6px)'},{transform:'translateX(6px)'},{transform:'translateX(0)'}],{duration:220});
        }
        return;
      }

      // å€¼ç›¸åŒï¼Œå°è¯•æ‰¾è¿çº¿
      const path = canConnect(tilesMap[firstId].r, tilesMap[firstId].c, tilesMap[secondId].r, tilesMap[secondId].c);
      if(path){
        // åŒ¹é…æˆåŠŸ
        matchedCount++; matchedEl.textContent = matchedCount; remainingEl.textContent = totalPairs - matchedCount;
        if(tilesMap[firstId] && tilesMap[firstId].el) tilesMap[firstId].el.classList.add('hidden');
        if(tilesMap[secondId] && tilesMap[secondId].el) tilesMap[secondId].el.classList.add('hidden');
        // ä»é€»è¾‘ç›˜é¢ç§»é™¤
        board[tilesMap[firstId].r][tilesMap[firstId].c] = 0;
        board[tilesMap[secondId].r][tilesMap[secondId].c] = 0;
        // ç”»è·¯å¾„
        drawPathOnBoard(path);
        // æ¸…ç†å¼•ç”¨
        delete tilesMap[firstId]; delete tilesMap[secondId];
        // æ£€æŸ¥èƒœåˆ©
        if(matchedCount >= totalPairs){ setTimeout(()=>{ alert('æ­å–œï¼æ‰€æœ‰é…å¯¹å·²å®Œæˆï¼ç”¨æ—¶ï¼š' + formatTime(timer) + 'ï¼Œæ­¥æ•°ï¼š' + moves); resetTimer(); }, 160); }
      } else {
        // æ— æ³•è¿é€šï¼Œæç¤ºåé¦ˆ
        if(tilesMap[secondId] && tilesMap[secondId].el){ tilesMap[secondId].el.animate([{transform:'scale(.96)'},{transform:'scale(1)'}],{duration:160}); }
      }
    }

    // --- å¯»è·¯ï¼šè¿”å›è·¯å¾„ç‚¹æ•°ç»„ï¼ˆæ”¯æŒå¤–è¾¹ç•Œåæ ‡ï¼‰ ---
    function canConnect(r1,c1,r2,c2){
      const R = rows+2, C = cols+2;
      const visited = Array.from({length:R}, ()=>Array.from({length:C}, ()=>Array(4).fill(99)));
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]]; // ä¸Šä¸‹å·¦å³
      const q = [];
      for(let d=0; d<4; d++){ visited[r1][c1][d] = 0; q.push({r:r1,c:c1,dir:d,turns:0,prev:null}); }

      function passable(nr,nc){ if(nr<0||nr>=R||nc<0||nc>=C) return false; if(nr===r2 && nc===c2) return true; return board[nr] && board[nr][nc]===0; }

      while(q.length){
        const cur = q.shift();
        let nr = cur.r + dirs[cur.dir][0];
        let nc = cur.c + dirs[cur.dir][1];
        while(nr>=0 && nr<R && nc>=0 && nc<C){
          if(!passable(nr,nc)) break;
          if(nr===r2 && nc===c2){
            // æ‰¾åˆ°ç›®æ ‡ï¼šé‡å»ºè·¯å¾„
            const path = reconstruct({r:nr,c:nc,dir:cur.dir,prev:{r:cur.r,c:cur.c,dir:cur.dir,prev:cur.prev}});
            return path;
          }
          for(let nd=0; nd<4; nd++){
            const extraTurns = (nd===cur.dir)?0:1;
            const newTurns = cur.turns + extraTurns;
            if(newTurns>2) continue;
            if(visited[nr][nc][nd] > newTurns){ visited[nr][nc][nd] = newTurns; q.push({r:nr,c:nc,dir:nd,turns:newTurns,prev:{r:cur.r,c:cur.c,dir:cur.dir,prev:cur.prev}}); }
          }
          nr += dirs[cur.dir][0]; nc += dirs[cur.dir][1];
        }
      }
      return null;

      function reconstruct(node){
        const pts = [];
        pts.push({r:node.r,c:node.c});
        let cur = node.prev;
        while(cur){ pts.push({r:cur.r,c:cur.c}); cur = cur.prev; }
        pts.reverse();
        return pts;
      }
    }

    // --- ç»˜åˆ¶è·¯å¾„ï¼ˆæ”¯æŒè¾¹ç•Œç‚¹ï¼‰ ---
    function drawPathOnBoard(path){
      clearPathLines(); if(!path || !path.length) return;
      const rect = gridEl.getBoundingClientRect(); if(rect.width===0 || rect.height===0) return;
      const cellW = rect.width / cols; const cellH = rect.height / rows;
      function centerFor(p){
        const cx = (p.c <= 0) ? (-cellW/2) : (p.c > cols) ? (rect.width + cellW/2) : ((p.c - 1 + 0.5) * cellW);
        const cy = (p.r <= 0) ? (-cellH/2) : (p.r > rows) ? (rect.height + cellH/2) : ((p.r - 1 + 0.5) * cellH);
        return [cx, cy];
      }
      const points = path.map(p => centerFor(p));
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('class','path-line'); svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`); svg.style.left='0px'; svg.style.top='0px'; svg.style.width='100%'; svg.style.height='100%';
      const pathEl = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = points.map(p=>p.join(',')).join(' ');
      pathEl.setAttribute('points', pts); pathEl.setAttribute('fill','none'); pathEl.setAttribute('stroke','rgba(6,182,212,0.95)'); pathEl.setAttribute('stroke-width', Math.max(3, Math.min(8, rect.width/160))); pathEl.setAttribute('stroke-linecap','round'); pathEl.setAttribute('stroke-linejoin','round');
      svg.appendChild(pathEl); gridEl.appendChild(svg);
      try{ const anim = pathEl.animate([{opacity:1},{opacity:0}],{duration:700}); anim.onfinish = ()=>{ try{ svg.remove(); }catch(e){} }; }catch(e){ setTimeout(()=>{ try{ svg.remove(); }catch(e){} },700); }
    }

    function clearPathLines(){ const els = gridEl.querySelectorAll('.path-line'); els.forEach(e=>e.remove()); }

    // --- æç¤ºåŠŸèƒ½ï¼šæ‰¾åˆ°ä»»æ„å¯è¿çš„å¯¹å¹¶çŸ­æš‚é«˜äº® ---
    function findHint(){
      const ids = Object.keys(tilesMap).map(x=>Number(x));
      for(let i=0;i<ids.length;i++){
        for(let j=i+1;j<ids.length;j++){
          const a = tilesMap[ids[i]], b = tilesMap[ids[j]];
          if(!a||!b) continue; if(a.val !== b.val) continue;
          const p = canConnect(a.r, a.c, b.r, b.c);
          if(p) return [ids[i], ids[j], p];
        }
      }
      return null;
    }

    function hintAction(){
      const found = findHint();
      if(!found){ alert('æ²¡æœ‰å¯æ¶ˆé™¤çš„é…å¯¹ï¼ˆå¯èƒ½å·²ç»æ— è§£ï¼‰ï¼Œä½ å¯ä»¥é‡æ–°å¼€å§‹ã€‚'); return; }
      const [id1,id2,path] = found; const el1 = tilesMap[id1] && tilesMap[id1].el; const el2 = tilesMap[id2] && tilesMap[id2].el;
      if(el1) el1.classList.add('selected'); if(el2) el2.classList.add('selected');
      drawPathOnBoard(path);
      setTimeout(()=>{ if(el1) el1.classList.remove('selected'); if(el2) el2.classList.remove('selected'); clearPathLines(); },700);
      moves++; movesEl.textContent = moves;
    }

    // --- æ–°æ¸¸æˆ ---
    function newGame(){ setDifficulty(difficultyEl.value); moves = 0; matchedCount = 0; selected = null; resetTimer(); generateSolvableBoard(); render(); }

    // ç»‘å®š UI
    newBtn.addEventListener('click', newGame);
    difficultyEl.addEventListener('change', newGame);
    hintBtn.addEventListener('click', hintAction);
    scaleEl.addEventListener('input', applyScale);

    // åˆå§‹å¯åŠ¨
    newGame();

    // ç›‘å¬çª—å£å°ºå¯¸å˜åŒ–ä»¥åˆ·æ–°è·¯å¾„ç­‰
    window.addEventListener('resize', ()=>{ clearPathLines(); applyScale(); });

    // è§¦æ‘¸é˜»æ­¢é»˜è®¤æ»šåŠ¨
    gridEl.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});

  })();
  </script>
</body>
</html>
